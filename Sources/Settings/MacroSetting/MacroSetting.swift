/// Type-safe `UserDefaults` access with automatic keys, defaults, and optional encoding control.
///
/// ### Quick start
/// ```swift
/// @Settings(prefix: "com.example.app.")
/// struct AppSettings {
///     @Setting var username: String = "guest"          // plist-native
///     @Setting var lastLogin: Date?                     // optional, no default
///     @Setting(name: "flag") var isFlagSet: Bool = false
///     @Setting(encoding: .json) var profile: Profile = .empty
/// }
/// ```
/// - Declare the property inside a `__Settings_Container` (generated by `@Settings`) or supply your own.
/// - When `name` is omitted the key defaults to the fully-qualified property name.
/// - Initial values for non-optional types become registered defaults.
/// - Without a surrounding container macro the standard store is used.
///
///
/// ### Namespacing
/// Extend the container (or nested enums/classes) and apply `@Setting` to group keys:
/// ```swift
/// extension AppSettings { enum Developer {} }
/// extension AppSettings.Developer {
///   @Setting var featureFlag: Bool = false
/// }
/// ```
/// Keys generated inside nested scopes include the path (e.g. `Developer::featureFlag`).
///
/// ### Encoding options
/// Use one of the following to control how custom `Codable` values are stored:
/// | Parameter                     | Effect |
/// | ----------------------------- | ------ |
/// | _none_                        | rely on runtime heuristics (plist-native types store raw, codable types require no explicit coder) |
/// | `encoding: .json`             | generate `JSONEncoder`/`JSONDecoder` properties |
/// | `encoding: .plist`            | generate `PropertyListEncoder`/`PropertyListDecoder` |
/// | `encoder:/decoder:` pair      | provide exact expressions or closures returning `AttributeEncoding` / `AttributeDecoding` |
///
/// Rules:
/// - `encoding:` and `encoder:/decoder:` are mutually exclusive.
/// - When supplying explicit providers, both `encoder:` and `decoder:` must be present.
/// - Property-listâ€“native types (Bool, numbers, String, Date, Data, URL, arrays/dictionaries of plist values) need no coders.
///
/// ### Example for custom JSON settings:
///
/// ```swift
/// extension AppSettings {
///   @Setting(
///     encoder: {
///       let encoder = JSONEncoder()
///       encoder.keyEncodingStrategy = .convertToSnakeCase
///       encoder.dateEncodingStrategy = .iso8601
///       return encoder
///     }(),
///     decoder: {
///       let decoder = JSONDecoder()
///       decoder.keyDecodingStrategy = .convertFromSnakeCase
///       decoder.dateDecodingStrategy = .formatted(DateFormatter.custom)
///       return decoder
///     }()
///   )
///   var legacyProfile: Profile = .empty
/// }
/// ```
/// *(Replace `DateFormatter.custom` with your project-specific formatter or helper.)*
///
/// Key takeaways:
/// - Configure `JSONEncoder`/`JSONDecoder` however you like; the macro copies the expressions verbatim.
/// - Prefer `.json` / `.plist` for common cases; switch to explicit providers when strategies diverge.
/// - You can wrap configuration in factory methods if the inline closure becomes too large.
@attached(accessor)
@attached(peer, names: prefixed(`$`), arbitrary)
public macro Setting(
    name: String? = nil,
    encoding: AttributeEncodingStrategy? = nil,
    encoder: Any? = nil,
    decoder: Any? = nil
) = #externalMacro(
    module: "SettingsMacros",
    type: "SettingMacro"
)
